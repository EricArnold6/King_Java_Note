# Kafka基础

- 主要参考自：https://www.bilibili.com/video/BV1Xy4y1G7zA?p=3

# 1.为什么要使用消息队列?

- 使用同步的通信方式来解决多个服务之间的通信：
  - ![image-20220107111429935](1_Kafka%E5%9F%BA%E7%A1%80.assets/image-20220107111429935.png)
  - 带来的问题：
    - 性能和稳定性的问题
- 使用异步的通信方式来解决多个服务之间的通信：
  - ![image-20220107112712877](1_Kafka%E5%9F%BA%E7%A1%80.assets/image-20220107112712877.png)
  - 带来的问题：
    - 服务失败怎么解决？分布式事务来解决！
  - 优点：极大提高系统的吞吐量，并且在分布式系统中，可以通过下游的多个服务的分布式事务的保障，也能解决业务执行之后的最终一致性
- 消息队列解决的是什么问题？
  - 通信问题！
  - 异步通信！
  - 像之前的HTTP、Dubbo都是同步的通信方式

# 2. 消息队列概述

## 2.1 什么是消息队列？

- Message Queue；消息队列中间件
  - MQ的效果：通过消息的发送和接收分离来实现应用程序的异步和解耦
  - MQ的目的：通信！屏蔽底层复杂的通信协议，定义一套应用层的更加简单的通信协议。
  - 一个分布式系统中两个模块之间通讯要么是HTTP,要么是自己开发的(rpc) TCP， 但是这两种协议其实都是原始的协议。HTTP协议很难实现两端通讯--模块 A可以调用B, B也可以主动调用A,如果要做到这个两端都要背上WebServer,而且还不支持长连接(HTTP 2.0的库根本找不到)。TCP就更加原始了，粘包、心跳、私有的协议。
  - MQ所要做的就是在这些协议之上构建一个简单的“协议"--生产者/消费者模型。MQ带给我的“协议"不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象--发送数据的叫生产者;接收数据的叫消费者，提供一 个SDK让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议

## 2.2 消息队列的流派

- 目前消息队列的中间件有很多：
  - RabbitMQ：轻Topic，功能多可玩性高
  - RockerMQ：阿里的，原理与Kafka类似，性能与Kafka相当，实现了更多的功能
  - Kafka：重Topic，全世界性能最高
  - zeroMQ：无Broker
- 这些消息队列中间件的区别？
  - 有Broker的MQ：
    - 通常有一台服务器作为Broker，所有的消息通过它进行中转，生产者把消息发送给它将结束了自己的任务，Broker则把消息主动推送给消费者(消费者主动轮询也可以)
    - **重Topic：**
      - kafka、JMS (ActiveMQ) 就属于这个流派，生产者会发送key和数据到Broker,由Broker比较key之后决定给哪个消费者。这种模式是我们最常见的模式，是我们对MQ最多的印象。在这种模式下一个topic往往是一个比较大的概念，甚至-一个系统中就可能只有一个topic, topic 某种意义上就是queue,生产者发送key相当于说: "hi, 把数据放到key的队列中”
      - ![image-20220107134845655](1_Kafka%E5%9F%BA%E7%A1%80.assets/image-20220107134845655.png)
    - **轻Topic:**
      - 这种的代表是RabbitMQ (或者说是AMQP)。生产者发送key和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出key对应的队列，然后把数据交给队列
      - ![image-20220107135906164](1_Kafka%E5%9F%BA%E7%A1%80.assets/image-20220107135906164.png)
      - 这种模式下解耦了key和queue,在这种架构中queue是非常轻量级的(在 RabbitMQ中它的.上限取决于你的内存)，消费者关心的只是自己的queue;生产者不必关心数据最终给谁只要指定key就行了，中间的那层映射在AMQP中叫exchange (交换机)。
      - AMQP中有四种exchange
        - Direct exchange: key就等于queue
        - Fanout exchange: 无视key,给所有的queue都来- -份
        - Topic exchange: key 可以用"宽字符"模糊匹配queue
        - Headers exchange: 无视key, 通过查看消息的头部元数据来决定发给那个queue (AMQP头部元数据非常丰富而且可以自定义)
      - 这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种exchange表达出来。如果你需要一个企业数据总线(在乎灵活性)那么RabbitMQ绝对的值得用
  - 无Broker的MQ：
    - 无Broker的MQ的代表是ZeroMQ。该作者非常睿智，他非常敏锐的意识到一- MQ 是更高级的Socket,它是解决通讯问题的。所以ZeroMQ被设计成了一个“库”而不是一个中间件， 这种实现也可以达到没有Broker的目的
    - ![image-20220107140743869](1_Kafka%E5%9F%BA%E7%A1%80.assets/image-20220107140743869.png)
    - 节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ做的事情就是封装出一套类似于Socket的API可以完成发送数据，读取数据.
    - ZeroMQ其实就是一个跨语言的、重量级的Actor模型邮箱库。你可以把自己的程序想象成一个Actor, ZeroMQ就是提供邮箱功能的库; ZeroMQ可以实现同一台机器的RPC通讯也可以实现不同机器的TCP、UDP通讯，如果你需要一个强大的、 灵活、野蛮的通讯能 力，别犹豫ZeroMQ

